"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeSchema = exports.TimeDimension = void 0;
const ramda_1 = __importDefault(require("ramda"));
const moment_timezone_1 = __importDefault(require("moment-timezone"));
const nexus_1 = require("nexus");
const graphql_scalars_1 = require("graphql-scalars");
const query_1 = require("./query");
const DateTimeScalar = nexus_1.asNexusMethod(graphql_scalars_1.DateTimeResolver, 'date');
const FloatFilter = nexus_1.inputObjectType({
    name: 'FloatFilter',
    definition(t) {
        t.float('equals');
        t.float('notEquals');
        t.list.float('in');
        t.list.float('notIn');
        t.float('contains');
        t.float('notContains');
        t.boolean('set');
    }
});
const StringFilter = nexus_1.inputObjectType({
    name: 'StringFilter',
    definition(t) {
        t.string('equals');
        t.string('notEquals');
        t.list.string('in');
        t.list.string('notIn');
        t.string('contains');
        t.string('notContains');
        t.boolean('set');
    }
});
const DateTimeFilter = nexus_1.inputObjectType({
    name: 'DateTimeFilter',
    definition(t) {
        t.string('equals');
        t.string('notEquals');
        t.list.string('in');
        t.list.string('notIn');
        t.list.string('inDateRange');
        t.list.string('notInDateRange');
        t.string('beforeDate');
        t.string('afterDate');
        t.boolean('set');
    }
});
const OrderBy = nexus_1.enumType({
    name: 'OrderBy',
    members: [
        'asc',
        'desc'
    ]
});
exports.TimeDimension = nexus_1.objectType({
    name: 'TimeDimension',
    definition(t) {
        t.nonNull.field('value', {
            type: 'DateTime',
        });
        t.nonNull.field('second', {
            type: 'DateTime',
        });
        t.nonNull.field('minute', {
            type: 'DateTime',
        });
        t.nonNull.field('hour', {
            type: 'DateTime',
        });
        t.nonNull.field('day', {
            type: 'DateTime',
        });
        t.nonNull.field('week', {
            type: 'DateTime',
        });
        t.nonNull.field('month', {
            type: 'DateTime',
        });
        t.nonNull.field('quarter', {
            type: 'DateTime'
        });
        t.nonNull.field('year', {
            type: 'DateTime',
        });
    },
});
function mapType(type, isInputType) {
    switch (type) {
        case 'time':
            return isInputType ? 'DateTime' : 'TimeDimension';
        case 'string':
            return 'String';
        case 'number':
            return 'Float';
        default:
            return 'String';
    }
}
function mapWhereOperator(operator, value) {
    switch (operator) {
        case 'in':
            return 'equals';
        case 'notIn':
            return 'notEquals';
        case 'set':
            return (value === true) ? 'set' : 'notSet';
        default:
            return operator;
    }
}
function mapWhereValue(operator, value) {
    switch (operator) {
        case 'set':
            return undefined;
        default:
            return Array.isArray(value) ? value.map(v => `${v}`) : [`${value}`];
    }
}
function safeName(name) {
    return name.split('.').slice(1).join('');
}
function capitalize(name) {
    return `${name[0].toUpperCase()}${name.slice(1)}`;
}
function unCapitalize(name) {
    return `${name[0].toLowerCase()}${name.slice(1)}`;
}
function applyDirectives(directives, values) {
    if (directives === undefined || directives.length === 0) {
        return true;
    }
    return directives.reduce((result, directive) => {
        var _a;
        (_a = directive.arguments) === null || _a === void 0 ? void 0 : _a.forEach((argument) => {
            if (argument.name.value === 'if') {
                if ((directive.name.value === 'include' &&
                    !values[argument.value.name.value]) ||
                    (directive.name.value === 'skip' &&
                        values[argument.value.name.value])) {
                    result = false;
                }
            }
        });
        return result;
    }, true);
}
function getFieldNodeChildren(node, infos) {
    var _a;
    return (((_a = node.selectionSet) === null || _a === void 0 ? void 0 : _a.selections.filter((childNode) => (childNode.kind === 'Field' &&
        childNode.name.value !== '__typename' &&
        applyDirectives(childNode.directives, infos.variableValues)))) || []);
}
function parseArgumentValue(value) {
    switch (value.kind) {
        case 'BooleanValue':
        case 'IntValue':
        case 'StringValue':
        case 'FloatValue':
        case 'EnumValue':
            return value.value;
        case 'ListValue':
            return value.values.map(v => parseArgumentValue(v));
        case 'ObjectValue':
            return value.fields.reduce((obj, v) => ({
                ...obj,
                [v.name.value]: parseArgumentValue(v.value),
            }), {});
        default:
            return undefined;
    }
}
function getArgumentValue(node, argName) {
    var _a, _b;
    const argument = (_b = (_a = node.arguments) === null || _a === void 0 ? void 0 : _a.find(a => a.name.value === argName)) === null || _b === void 0 ? void 0 : _b.value;
    return argument ? parseArgumentValue(argument) : argument;
}
function getMemberType(metaConfig, cubeName, memberName) {
    const cubeConfig = metaConfig.find(cube => cube.config.name === cubeName);
    if (!cubeConfig)
        return undefined;
    return ['measure', 'dimension'].find((memberType) => (cubeConfig.config[`${memberType}s`]
        .findIndex(entry => entry.name === `${cubeName}.${memberName}`) !== -1));
}
function whereArgToQueryFilters(whereArg, prefix) {
    const queryFilters = [];
    Object.keys(whereArg).forEach(member => {
        if (member === 'OR') {
            queryFilters.push({
                or: whereArg[member].reduce((filters, whereBooleanArg) => ([...filters, ...whereArgToQueryFilters(whereBooleanArg, prefix)]), [])
            });
        }
        else if (member === 'AND') {
            queryFilters.push({
                and: whereArg[member].reduce((filters, whereBooleanArg) => ([...filters, ...whereArgToQueryFilters(whereBooleanArg, prefix)]), [])
            });
        }
        else {
            Object.keys(whereArg[member]).forEach(operator => {
                const value = whereArg[member][operator];
                queryFilters.push({
                    member: prefix ? `${prefix}.${member}` : member,
                    operator: mapWhereOperator(operator, value),
                    ...(mapWhereValue(operator, value) && {
                        values: mapWhereValue(operator, value)
                    })
                });
            });
        }
    });
    return queryFilters;
}
function rootWhereArgToQueryFilters(whereArg) {
    return Object.keys(whereArg).reduce((filters, cubeName) => ([...filters, ...whereArgToQueryFilters(whereArg[cubeName], capitalize(cubeName))]), []);
}
function parseDates(result) {
    const { timezone } = result.query;
    const dateKeys = Object.entries({
        ...result.annotation.measures,
        ...result.annotation.dimensions,
        ...result.annotation.timeDimensions,
    }).reduce((res, [key, value]) => (value.type === 'time' ? [...res, key] : res), []);
    result.data.forEach(row => {
        Object.keys(row).forEach(key => {
            if (dateKeys.includes(key)) {
                row[key] = moment_timezone_1.default.tz(row[key], timezone).toISOString();
            }
            return row;
        });
    });
}
function makeSchema(metaConfig) {
    const types = [
        DateTimeScalar,
        FloatFilter,
        StringFilter,
        DateTimeFilter,
        OrderBy,
        exports.TimeDimension
    ];
    metaConfig.forEach(cube => {
        types.push(nexus_1.objectType({
            name: `${cube.config.name}Members`,
            definition(t) {
                cube.config.measures.forEach(measure => {
                    if (measure.isVisible) {
                        t.nonNull.field(safeName(measure.name), {
                            type: mapType(measure.type),
                            description: measure.description
                        });
                    }
                });
                cube.config.dimensions.forEach(dimension => {
                    if (dimension.isVisible) {
                        t.nonNull.field(safeName(dimension.name), {
                            type: mapType(dimension.type),
                            description: dimension.description
                        });
                    }
                });
            }
        }));
        types.push(nexus_1.inputObjectType({
            name: `${cube.config.name}WhereInput`,
            definition(t) {
                t.field('AND', { type: nexus_1.list(nexus_1.nonNull(`${cube.config.name}WhereInput`)) });
                t.field('OR', { type: nexus_1.list(nexus_1.nonNull(`${cube.config.name}WhereInput`)) });
                cube.config.measures.forEach(measure => {
                    if (measure.isVisible) {
                        t.field(safeName(measure.name), {
                            type: `${mapType(measure.type, true)}Filter`,
                        });
                    }
                });
                cube.config.dimensions.forEach(dimension => {
                    if (dimension.isVisible) {
                        t.field(safeName(dimension.name), {
                            type: `${mapType(dimension.type, true)}Filter`,
                        });
                    }
                });
            }
        }));
        types.push(nexus_1.inputObjectType({
            name: `${cube.config.name}OrderByInput`,
            definition(t) {
                cube.config.measures.forEach(measure => {
                    if (measure.isVisible) {
                        t.field(safeName(measure.name), {
                            type: 'OrderBy',
                        });
                    }
                });
                cube.config.dimensions.forEach(dimension => {
                    if (dimension.isVisible) {
                        t.field(safeName(dimension.name), {
                            type: 'OrderBy',
                        });
                    }
                });
            }
        }));
    });
    types.push(nexus_1.inputObjectType({
        name: 'RootWhereInput',
        definition(t) {
            t.field('AND', { type: nexus_1.list(nexus_1.nonNull('RootWhereInput')) });
            t.field('OR', { type: nexus_1.list(nexus_1.nonNull('RootWhereInput')) });
            metaConfig.forEach(cube => {
                t.field(unCapitalize(cube.config.name), {
                    type: `${cube.config.name}WhereInput`
                });
            });
        }
    }));
    types.push(nexus_1.objectType({
        name: 'Result',
        definition(t) {
            metaConfig.forEach(cube => {
                t.nonNull.field(unCapitalize(cube.config.name), {
                    type: `${cube.config.name}Members`,
                    args: {
                        where: nexus_1.arg({
                            type: `${cube.config.name}WhereInput`
                        }),
                        orderBy: nexus_1.arg({
                            type: `${cube.config.name}OrderByInput`
                        }),
                    }
                });
            });
        }
    }));
    types.push(nexus_1.extendType({
        type: 'Query',
        definition(t) {
            t.nonNull.field('load', {
                type: nexus_1.list(nexus_1.nonNull('Result')),
                args: {
                    where: nexus_1.arg({
                        type: 'RootWhereInput'
                    }),
                    limit: nexus_1.intArg(),
                    offset: nexus_1.intArg(),
                    timezone: nexus_1.stringArg(),
                    renewQuery: nexus_1.booleanArg(),
                },
                resolve: async (parent, { where, limit, offset, timezone, renewQuery }, { req, apiGateway }, infos) => {
                    const measures = [];
                    const dimensions = [];
                    const timeDimensions = [];
                    let filters = [];
                    const order = {};
                    if (where) {
                        filters = [...filters, ...rootWhereArgToQueryFilters(where)];
                    }
                    getFieldNodeChildren(infos.fieldNodes[0], infos).forEach(cubeNode => {
                        const cubeName = capitalize(cubeNode.name.value);
                        const orderByArg = getArgumentValue(cubeNode, 'orderBy');
                        if (orderByArg) {
                            Object.keys(orderByArg).forEach(key => {
                                order[`${cubeName}.${key}`] = orderByArg[key];
                            });
                        }
                        const whereArg = getArgumentValue(cubeNode, 'where');
                        if (whereArg) {
                            filters = [...filters, ...whereArgToQueryFilters(whereArg, cubeName)];
                        }
                        getFieldNodeChildren(cubeNode, infos).forEach(memberNode => {
                            const memberName = memberNode.name.value;
                            const memberType = getMemberType(metaConfig, cubeName, memberName);
                            if (memberType === 'measure') {
                                measures.push(`${cubeName}.${memberName}`);
                            }
                            else if (memberType === 'dimension') {
                                const granularityNodes = getFieldNodeChildren(memberNode, infos);
                                if (granularityNodes.length > 0) {
                                    granularityNodes.forEach(granularityNode => {
                                        const granularityName = granularityNode.name.value;
                                        if (granularityName === 'value') {
                                            dimensions.push(`${cubeName}.${memberName}`);
                                        }
                                        else {
                                            timeDimensions.push({
                                                dimension: `${cubeName}.${memberName}`,
                                                granularity: granularityName
                                            });
                                        }
                                    });
                                }
                                else {
                                    dimensions.push(`${cubeName}.${memberName}`);
                                }
                            }
                        });
                    });
                    const query = {
                        ...(measures.length && { measures }),
                        ...(dimensions.length && { dimensions }),
                        ...(timeDimensions.length && { timeDimensions }),
                        ...(Object.keys(order).length && { order }),
                        ...(limit && { limit }),
                        ...(offset && { offset }),
                        ...(timezone && { timezone }),
                        ...(filters.length && { filters }),
                        ...(renewQuery && { renewQuery }),
                    };
                    // eslint-disable-next-line no-async-promise-executor
                    const results = await (new Promise(async (resolve, reject) => {
                        try {
                            await apiGateway.load({
                                query,
                                queryType: query_1.QUERY_TYPE.REGULAR_QUERY,
                                context: req.context,
                                res: (message) => {
                                    if (message.error) {
                                        reject(new Error(message.error));
                                    }
                                    resolve(message);
                                },
                            });
                        }
                        catch (e) {
                            reject(e);
                        }
                    }));
                    parseDates(results);
                    return results.data.map(entry => ramda_1.default.toPairs(entry)
                        .reduce((res, pair) => {
                        var _a;
                        let path = pair[0].split('.');
                        path[0] = unCapitalize(path[0]);
                        if (((_a = results.annotation.dimensions[pair[0]]) === null || _a === void 0 ? void 0 : _a.type) === 'time') {
                            path = [...path, 'value'];
                        }
                        return (results.annotation.timeDimensions[pair[0]] && path.length !== 3)
                            ? res : ramda_1.default.set(ramda_1.default.lensPath(path), pair[1], res);
                    }, {}));
                }
            });
        }
    }));
    return nexus_1.makeSchema({ types });
}
exports.makeSchema = makeSchema;
//# sourceMappingURL=graphql.js.map